<%_ /* templates/web/render/passport/utils/token-store.ejs */ _%>
// This file is /utils/token-store.js

// Bearer token store with in-memory fallback and hardened DB storage (hash only).
import { randomHex } from './encryption-handler.js';
import { tokenHash as hashToken, timingSafeEqualStr } from './security.js';

// Try to import Postgres pool if the project was scaffolded with PG
let database = null;
try {
  const mod = await import('../config/database.js');
  database = mod?.database || null;
} catch (_) {
  database = null;
}

const DEFAULT_TTL_SEC = 60 * 60 * 24 * 30; // 30 days

// In-memory fallback: Map<tokenHash, { userId, scopes, expiresAt:number, token?:string }>
const mem = new Map();

async function initPg() {
  if (!database) return;
  await database.query(`
    CREATE TABLE IF NOT EXISTS api_tokens (
      token_hash TEXT PRIMARY KEY,
      user_id   TEXT NOT NULL,
      scopes    TEXT,
      expires_at TIMESTAMPTZ NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
  `);
  await database.query(
    'CREATE INDEX IF NOT EXISTS api_tokens_expires_at_idx ON api_tokens(expires_at)'
  );
}

function randomToken(bytes = 32) {
  return randomHex(bytes);
}

export async function issueToken({ userId, scopes = [], ttlSec = DEFAULT_TTL_SEC } = {}) {
  if (!userId) throw new Error('issueToken: userId is required');
  const token = randomToken();               // plaintext returned once to caller
  const tHash = hashToken(token);            // only the hash is persisted
  const expiresAtMs = Date.now() + ttlSec * 1000;

  if (database) {
    await initPg();
    await database.query(
      'INSERT INTO api_tokens(token_hash, user_id, scopes, expires_at) VALUES($1,$2,$3,TO_TIMESTAMP($4/1000.0))',
      [tHash, String(userId), JSON.stringify(scopes), expiresAtMs]
    );
  } else {
    mem.set(tHash, { userId: String(userId), scopes: Array.from(scopes), expiresAt: expiresAtMs, token });
  }
  return token;
}

export async function verifyToken(token) {
  if (!token) return null;
  const tHash = hashToken(token);

  if (database) {
    const { rows } = await database.query(
      'SELECT user_id, scopes, EXTRACT(EPOCH FROM expires_at) * 1000 AS exp FROM api_tokens WHERE token_hash=$1',
      [tHash]
    );
    if (!rows.length) return null;
    const row = rows[0];
    if (Date.now() >= Number(row.exp)) return null;

    const scopes = typeof row.scopes === 'string' && row.scopes.length ? JSON.parse(row.scopes) : [];
    return { userId: row.user_id, scopes };
  }

  const rec = mem.get(tHash);
  if (!rec) return null;
  if (Date.now() >= rec.expiresAt) return null;

  // Optional timing-safe compare when plaintext retained in memory
  if (rec.token && !timingSafeEqualStr(rec.token, token)) return null;

  return { userId: rec.userId, scopes: rec.scopes };
}

export async function revokeToken(token) {
  if (!token) return false;
  const tHash = hashToken(token);

  if (database) {
    const { rowCount } = await database.query('DELETE FROM api_tokens WHERE token_hash=$1', [tHash]);
    return rowCount > 0;
  }
  return mem.delete(tHash);
}

export async function pruneExpired() {
  if (database) {
    await database.query('DELETE FROM api_tokens WHERE expires_at <= NOW()');
    return;
  }
  const now = Date.now();
  for (const [t, rec] of mem.entries()) {
    if (rec.expiresAt <= now) mem.delete(t);
  }
}
